#  数据结构

数据是存放在内存中的, 数据的存放方式有两种: 顺序存放和链式存放.

顺序存放一般申请一段连续的内存空间(可以理解为一个固定长度的数组), 将数组顺序存放在数组中.

链式存放是使用分散空间, 每次申请一个固定大小的结点, 结点中可以存放数据和指针(指向前后结点).

时间复杂度和空间复杂度是衡量算法的指标, 时间复杂度是算法执行耗费的时间, 空间复杂度是占用的内存.



## 1. 线性表

线性表分为顺序存储和链式存储

### 1.1 顺序存储-数组

顺序存储(数组)的管理

```c
int a[100];// 在内存中申请100个连续的内存空间
int *p = malloc(100 * sizeof(int));// 在堆内存中申请100个连续的内存空间
```

顺序存储的优缺点:

1. 查找方便, 时间复杂度O(1)
2. 添加删除不方便, 时间复杂度O(n)

数据类型定义

```c
// 存储空间, 定义长度
#define MAXSIZE 30
// 定义线性表中的元素(这里假定元素为int类型)
typedef int Element;
// 定义线性表数据类型
typedef struct {
    Element data[MAXSIZE];
    int length;
}List;
```

创建线性表

```c
// 创建线性表
Status initList(List *l) {
    l->length = 0;
    return OK;
}
```

线性表插入

```c
// 插入
Status insertElement(List *l, int i, Element e) {
    // 线性表未满
    // 插入范围正常
    if (l->length >= MAXSIZE){
        return ERROR;
    }
    if (i < 1 || i > MAXSIZE || i > (l->length + 1)) {
        return ERROR;
    }
    
    // 插入的位置在中间(需要将元素向后转移)
    if (i <= l->length) {
        for (int k = l->length; k >= i; k--) {
            l->data[k] = l->data[k - 1];
        }
    }
    
    // 将元素插入到对应位置
    l->data[i - 1] = e;
    l->length++;
    
    return OK;
}
```

线性表删除

```c
// 删除
Status deleteElement(List *l, int i, Element *e) {
    // 线性表不为空
    if (l->length <= 0) {
        return ERROR;
    }
    // 删除范围正常
    if (i < 1 || i > l->length) {
        return ERROR;
    }
    
    *e = l->data[i - 1];
    
    // 如果删除的不是最后一个
    if (i < l->length) {
        int k;
        for (k = i - 1; k < l->length - 1; k++) {
            l->data[k] = l->data[k + 1];
        }
    }
    l->length--;
    
    return OK;
}
```



### 1.2 链式存储-链表

链表结构

![image-20190108114549432](/Users/xygj/Library/Application Support/typora-user-images/image-20190108114549432.png)

结点数据

```c
typedef struct Tag_Node {
    Element data;// 节点存储的数据
    struct Tag_Node *next;// 指向下一个节点
}Node;
```

```c
// 定义链表, 指向结构体的指针, 个人理解相当于head
typedef Node *LinkList;
```

添加结点

```c
Status listInsert(LinkList *linkList, int i, Element e) {
    
    LinkList p, s;
    int j = 1;
    p = *linkList;// 头结点
    
    // 查找第i-1个节点
    while (p && j < i) {
        p = p->next;
        j++;
    }
    
    // 如果未查找到
    if (!p || j > i) {
        return ERROR;
    }
    
    // 创建节点
    s = malloc(sizeof(Node));
    s->data = e;
    s->next = p->next;
    p->next = s;
    
    return OK;
}
```

删除结点

```c
Status listDelete(LinkList *linkList, int i, Element *e) {
    LinkList p, s;
    int j = 1;
    p = *linkList;// 头结点
    
    // 查找第i-1个元素
    while (p->next && j < i) {
        p = p->next;
        j++;
    }
    
    // 如果未找到第i个元素
    if (!(p->next) || j > i) {
        return ERROR;
    }
    
    // 找到第i个元素
    s = p->next;
    p->next = s->next;
    *e = s->data;
    
    return OK;
}
```

### 1.3 数组和链表对比

数组和链表都是数据存储的方式, 但是数组只能存储固定大小的数据, 并且添加和删除不方便, 但是优势在于查找方便, 查找的时间复杂度为O(1).

链表方便添加和删除, 但是查找的时间复杂度为O(n).

在实际应用中应该结合数组和链表的特点, 用数组记录某个结点的地址, 根据某种映射关系, 用链表来组织这些数据的存放, 这样既可以快速定位位置, 又可以方便的添加和删除.



## 2. 栈和队列

栈和队列是两种特殊的数据管理方式.

栈是FILO, 先入后出, 只允许在栈顶添加和删除元素, 出栈和入栈.

队列是FIFO, 先入先出, 只允许在队首取元素, 在队尾添加元素.

### 2.1 栈

栈怎么来组织数据? 连续内存空间还是链式

连续的内存空间, 空间有上线, 假如申请了100个, 如果存储到101个数据的时候就会出现栈溢出的情况.

链式存储空间, 需要分配指针, 并且查找时间复杂度为O(n), 效率会低.

在实际应用中, 栈的一般是使用连续的存储内存空间.

数据类型定义

```c
#define MAXSIZE 100
typedef int Status;// Status是函数的类型,其值是函数结果状态代码，如OK等
typedef int Element;
typedef struct {
    Element data[MAXSIZE];
    int top;
}SqStack;
```

初始化栈

```c
// 初始化
Status initStack(SqStack *s) {
    s->top = -1;
    return OK;
}
// 销毁, 清空
Status clearStack(SqStack *s) {
    s->top = -1;
    return OK;
}
```

入栈

```c
// push
Status push(SqStack *s, Element e) {
    // 栈满
    if (s->top >= MAXSIZE - 1) {
        return ERROR;
    }
    
    s->top++;// 栈顶指针加1
    s->data[s->top] = e;
    
    return OK;
}
```

出栈

```c
// pop
Status pop(SqStack *s, Element *e) {
    // 空栈
    if (s->top == -1) {
        return ERROR;
    }
    *e = s->data[s->top];
    s->top--;
    
    return OK;
}
```

### 2.2 队列

数据类型定义

```c
typedef int Status;// Status是函数的类型,其值是函数结果状态代码，如OK等
typedef int Element;
// 定义节点
typedef struct Tag_Node {
    Element data;
    struct Tag_Node *next;// 指向下一个节点
}Node;
// 定义队列
typedef struct Tag_LinkQueue {
    Node *front;// top指针, 指向对头指针
    Node *rear;// 指向队尾指针
}LinkQueue;
```

队列初始化

```c
// 初始化
Status initLinkQueue(LinkQueue *queue) {
    // 头结点
    Node *headNode = malloc(sizeof(Node));
    headNode->next = NULL;
    if (!headNode) {
        return ERROR;
    }
    
    // 队头队尾指针指向 头结点
    queue->front = headNode;
    queue->rear = headNode;
    
    return OK;
}
```

入队列

```c
// 入队列
Status inLinkQueue(LinkQueue *queue, Element e) {
    // 创建节点
    Node *node = malloc(sizeof(Node));
    if (!node) {
        return ERROR;
    }
    node->data = e;
    node->next = NULL;
    
    queue->rear->next = node;
    
    queue->rear = node;
    
    return OK;
}
```

出队列

```c
// 出队列
Status outLinkQueue(LinkQueue *queue, Element *e) {
    // 空队列
    if (queue->front == queue->rear) {
        return ERROR;
    }
    Node *n = queue->front->next;
    *e = n->data;
    
    // 头结点指向下一个节点
    queue->front->next = n->next;
    
    if (queue->rear == n) {
        // 删除的最后一个节点
        queue->front = queue->rear;
    }
    
    // 释放节点内存
//    free(n);
    
    return OK;
}
```





